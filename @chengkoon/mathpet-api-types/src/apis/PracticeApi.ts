/* tslint:disable */
/* eslint-disable */
/**
 * API Documentation
 * This API exposes endpoints to manage entities and items.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorResponse,
  PracticeQuestionResponse,
  PracticeSessionResponse,
  QuestionAttemptResponse,
  StartPracticeSessionRequest,
  TopicPracticeSessionSummary,
  UpdatePracticeSessionRequest,
  UpdateQuestionAttemptRequest,
} from '../models/index';
import {
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    PracticeQuestionResponseFromJSON,
    PracticeQuestionResponseToJSON,
    PracticeSessionResponseFromJSON,
    PracticeSessionResponseToJSON,
    QuestionAttemptResponseFromJSON,
    QuestionAttemptResponseToJSON,
    StartPracticeSessionRequestFromJSON,
    StartPracticeSessionRequestToJSON,
    TopicPracticeSessionSummaryFromJSON,
    TopicPracticeSessionSummaryToJSON,
    UpdatePracticeSessionRequestFromJSON,
    UpdatePracticeSessionRequestToJSON,
    UpdateQuestionAttemptRequestFromJSON,
    UpdateQuestionAttemptRequestToJSON,
} from '../models/index';

export interface EndTopicPracticeSessionRequest {
    sessionId: string;
}

export interface GetPracticeSessionRequest {
    sessionId: string;
}

export interface GetPracticeSessionQuestionRequest {
    sessionId: string;
    questionIndex: number;
}

export interface GetUserPracticeSessionsRequest {
    status?: GetUserPracticeSessionsStatusEnum;
    packId?: string;
}

export interface StartPracticeSessionOperationRequest {
    startPracticeSessionRequest: StartPracticeSessionRequest;
}

export interface UpdatePracticeSessionOperationRequest {
    sessionId: string;
    updatePracticeSessionRequest: UpdatePracticeSessionRequest;
}

export interface UpdateQuestionAttemptOperationRequest {
    sessionId: string;
    updateQuestionAttemptRequest: UpdateQuestionAttemptRequest;
}

/**
 * 
 */
export class PracticeApi extends runtime.BaseAPI {

    /**
     * End the current topic practice session and get summary
     * End topic practice session
     */
    async endTopicPracticeSessionRaw(requestParameters: EndTopicPracticeSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopicPracticeSessionSummary>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling endTopicPracticeSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/practice/session/{sessionId}/end`;
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicPracticeSessionSummaryFromJSON(jsonValue));
    }

    /**
     * End the current topic practice session and get summary
     * End topic practice session
     */
    async endTopicPracticeSession(requestParameters: EndTopicPracticeSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopicPracticeSessionSummary> {
        const response = await this.endTopicPracticeSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve detailed information about a specific practice session
     * Get practice session details
     */
    async getPracticeSessionRaw(requestParameters: GetPracticeSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PracticeSessionResponse>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling getPracticeSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/practice/sessions/{sessionId}`;
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PracticeSessionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve detailed information about a specific practice session
     * Get practice session details
     */
    async getPracticeSession(requestParameters: GetPracticeSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PracticeSessionResponse> {
        const response = await this.getPracticeSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a specific question by its index in the practice session
     * Get specific question in practice session
     */
    async getPracticeSessionQuestionRaw(requestParameters: GetPracticeSessionQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PracticeQuestionResponse>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling getPracticeSessionQuestion().'
            );
        }

        if (requestParameters['questionIndex'] == null) {
            throw new runtime.RequiredError(
                'questionIndex',
                'Required parameter "questionIndex" was null or undefined when calling getPracticeSessionQuestion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/practice/sessions/{sessionId}/questions/{questionIndex}`;
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));
        urlPath = urlPath.replace(`{${"questionIndex"}}`, encodeURIComponent(String(requestParameters['questionIndex'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PracticeQuestionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific question by its index in the practice session
     * Get specific question in practice session
     */
    async getPracticeSessionQuestion(requestParameters: GetPracticeSessionQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PracticeQuestionResponse> {
        const response = await this.getPracticeSessionQuestionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all practice sessions for the authenticated user
     * Get user\'s practice sessions
     */
    async getUserPracticeSessionsRaw(requestParameters: GetUserPracticeSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PracticeSessionResponse>>> {
        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['packId'] != null) {
            queryParameters['packId'] = requestParameters['packId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/practice/sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PracticeSessionResponseFromJSON));
    }

    /**
     * Retrieve all practice sessions for the authenticated user
     * Get user\'s practice sessions
     */
    async getUserPracticeSessions(requestParameters: GetUserPracticeSessionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PracticeSessionResponse>> {
        const response = await this.getUserPracticeSessionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new practice session for a specific pack or topic
     * Start a new practice session
     */
    async startPracticeSessionRaw(requestParameters: StartPracticeSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PracticeSessionResponse>> {
        if (requestParameters['startPracticeSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'startPracticeSessionRequest',
                'Required parameter "startPracticeSessionRequest" was null or undefined when calling startPracticeSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/practice/sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StartPracticeSessionRequestToJSON(requestParameters['startPracticeSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PracticeSessionResponseFromJSON(jsonValue));
    }

    /**
     * Create a new practice session for a specific pack or topic
     * Start a new practice session
     */
    async startPracticeSession(requestParameters: StartPracticeSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PracticeSessionResponse> {
        const response = await this.startPracticeSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update session progress, current question, or completion status
     * Update practice session
     */
    async updatePracticeSessionRaw(requestParameters: UpdatePracticeSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PracticeSessionResponse>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling updatePracticeSession().'
            );
        }

        if (requestParameters['updatePracticeSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'updatePracticeSessionRequest',
                'Required parameter "updatePracticeSessionRequest" was null or undefined when calling updatePracticeSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/practice/sessions/{sessionId}`;
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePracticeSessionRequestToJSON(requestParameters['updatePracticeSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PracticeSessionResponseFromJSON(jsonValue));
    }

    /**
     * Update session progress, current question, or completion status
     * Update practice session
     */
    async updatePracticeSession(requestParameters: UpdatePracticeSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PracticeSessionResponse> {
        const response = await this.updatePracticeSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing question attempt with student\'s answer or skip status (for questions that already have a \"SEEN_ONLY\" attempt record)
     * Update existing question attempt
     */
    async updateQuestionAttemptRaw(requestParameters: UpdateQuestionAttemptOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionAttemptResponse>> {
        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling updateQuestionAttempt().'
            );
        }

        if (requestParameters['updateQuestionAttemptRequest'] == null) {
            throw new runtime.RequiredError(
                'updateQuestionAttemptRequest',
                'Required parameter "updateQuestionAttemptRequest" was null or undefined when calling updateQuestionAttempt().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/practice/sessions/{sessionId}/question/attempt`;
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateQuestionAttemptRequestToJSON(requestParameters['updateQuestionAttemptRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionAttemptResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing question attempt with student\'s answer or skip status (for questions that already have a \"SEEN_ONLY\" attempt record)
     * Update existing question attempt
     */
    async updateQuestionAttempt(requestParameters: UpdateQuestionAttemptOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionAttemptResponse> {
        const response = await this.updateQuestionAttemptRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetUserPracticeSessionsStatusEnum = {
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Abandoned: 'ABANDONED'
} as const;
export type GetUserPracticeSessionsStatusEnum = typeof GetUserPracticeSessionsStatusEnum[keyof typeof GetUserPracticeSessionsStatusEnum];
